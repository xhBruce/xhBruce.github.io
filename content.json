{"pages":[{"title":"","text":"记录断断续续写博客(1) Android、Java 相关经验分享(2) 日常总结、读书笔记。(3) 第三没有（IT 直男） 推荐 http://gityuan.com/ Gityuan 袁辉辉 http://www.trinea.cn/ trinea，专注于Android开源分享 https://droidyue.com/ 小黑屋，分享Android应用开发技术 http://p.codekk.com/?from=trinea.cn codekk，专注于Android开源分享、源码分析 http://stormzhang.com stormzhang，分享Android经验 http://androidxref.com/ androidxref.com，用于在线阅读Android系统源码 https://android-arsenal.com/ vbauer整理的Github开源库，国外整理最全面的库 https://github.com/Trinea/android-open-project Trinea整理的Github开源库，国内整理最全面的库 https://www.codota.com/ 收集各种API优秀示例Java代码并提供搜索功能 http://developer.android.com/intl/zh-cn/index.html Android官方网站；最权威的Google官方资料，首选资料 http://android-developers.blogspot.com/ Android官方博客：发布着官方资讯和技术博客 https://www.youtube.com/playlist?list=PLOU2XLYxmsIKEOXh5TwZEv89aofHzNCiu Android官方视频：Google发布于Youtube的官方Android性能优化的视频 http://androidweekly.net/ Android Weekly：由一群国外Android开发者维护 https://www.androidweekly.cn/ Android开发技术周报：由脉脉不嘚語维护 http://androidblog.cn/ Android博客周刊：由Jomeslu维护 http://liuwangshu.cn/ 刘望舒的博客 https://cuiqingcai.com/ 崔庆才的个人博客 https://redstonewill.com/category/deeplearning/ 红色石头 http://www.laitech.cn/ Light的博客 https://zhaomenghuan.js.org/blog/ 匠心博客 http://weishu.me/ Weishu’s Notes http://yifeiyuan.me/ 程序亦非猿 http://blogs.360.cn/ 360 核心安全技术博客 http://zh.lucida.me/ lucida http://celerysoft.github.io/index.html 月下之光 - 攸溟的个人博客 https://pqpo.me/ Pqpo’s Notes http://gank.io/ 干货集中营 http://lruheng.com/ ruheng 建blog历程 2016-09-11：CSDN上记录笔记 2018-03-31：购买域名xhbruce.cn和阿里独享虚拟主机经济版（贼贵） 2018-05-17：WordPress搭建blog 2019-03-29：WordPress转到Hexo上，并使用hexo-theme-icarus主题，Typora编辑Markdown","link":"/about/index.html"}],"posts":[{"title":"JAVA六大设计原则 和 23种设计模式","text":"相关书籍：《大话设计模式》、《Java设计模式》、《设计模式之禅》、《研磨设计模式》、《Head First 设计模式》 JAVA六大设计原则JAVA设计模式提供六个基本原则，分别是： 开闭原则(OCP) - The Open-Closed Principle 单一职责原则(SRP) - Single Responsibility Principle 里氏替换原则(LSP) - Liskov Substitution Principle 依赖倒置原则(DIP) - Dependency Inversion Principle 接口隔离原则(ISP) - Interface Segregation Principle 迪米特法则(DP) - Demeter Principle 开闭原则对扩展开放，对修改关闭。开闭原则宗旨是在已有系统基础上进行开发，不要对正常运行的代码进行修改操作。需要扩展需求时，通过添加新类或者新代码来实现，对已有代码做到最少修改，甚至是零修改。 单一职责原则接口或类只提供一种业务实现。单一职责原则宗旨是每个接口、类的功能，只能用来做专门的事，强调系统内业务职责唯一，避免职责扩散，做到业务统一管理。 里氏替换原则使用父类的地方可以用子类来替换。里氏替换原则宗旨是子类尽量不要重写父类或者接口中已经实现的方法，即子类和父类逻辑保持一致性。 依赖倒置原则面向抽象编程，即通过接口或者抽象类提供依赖关系。依赖倒置原则宗旨是指各个业务模块之间依赖关系，通过约定的接口或者抽象类来实现，不涉及具体的实现细节，细节交给具体的实现类来完成。JAVA实现依赖倒置的方式有三种： 构造方法 setter方法 接口注入接口隔离原则接口中的方法和属性都是实现类所需要，没有额外无用信息。接口隔离原则宗旨是接口的完美复用，接口的内容对于实现来说无冗余代码。 迪米特原则迪米特原则又叫最少知道原则，核心思想是低耦合，高内聚。迪米特原则宗旨是弱化代码（通常指类）之间的依赖关系。 总结六大设计原则是代码设计的基本原则。设计原则规范了开发人员如何去设计和实现代码，来提高程序的规范性、可读性、扩展性和维护性。 JAVA23种设计模式三个类型:创建型、结构型和行为型 创建型有：一、Singleton，单例模式：保证一个类只有一个实例，并提供一个访问它的全局访问点 二、Abstract Factory，抽象工厂：提供一个创建一系列相关或相互依赖对象的接口，而无须指定它们的具体类。三、Factory Method，工厂方法：定义一个用于创建对象的接口，让子类决定实例化哪一个类，Factory Method使一个类的实例化延迟到了子类。 四、Builder，建造模式：将一个复杂对象的构建与他的表示相分离，使得同样的构建过程可以创建不同的表示。 五、Prototype，原型模式：用原型实例指定创建对象的种类，并且通过拷贝这些原型来创建新的对象。 行为型有：六、Iterator，迭代器模式：提供一个方法顺序访问一个聚合对象的各个元素，而又不需要暴露该对象的内部表示。 七、Observer，观察者模式：定义对象间一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知自动更新。 八、Template Method，模板方法：定义一个操作中的算法的骨架，而将一些步骤延迟到子类中，TemplateMethod使得子类可以不改变一个算法的结构即可以重定义该算法得某些特定步骤。 九、Command，命令模式：将一个请求封装为一个对象，从而使你可以用不同的请求对客户进行参数化，对请求排队和记录请求日志，以及支持可撤销的操作。 十、State，状态模式：允许对象在其内部状态改变时改变他的行为。对象看起来似乎改变了他的类。 十一、Strategy，策略模式：定义一系列的算法，把他们一个个封装起来，并使他们可以互相替换，本模式使得算法可以独立于使用它们的客户。 十二、China of Responsibility，职责链模式：使多个对象都有机会处理请求，从而避免请求的送发者和接收者之间的耦合关系 十三、Mediator，中介者模式：用一个中介对象封装一些列的对象交互。 十四、Visitor，访问者模式：表示一个作用于某对象结构中的各元素的操作，它使你可以在不改变各元素类的前提下定义作用于这个元素的新操作。 十五、Interpreter，解释器模式：给定一个语言，定义他的文法的一个表示，并定义一个解释器，这个解释器使用该表示来解释语言中的句子。 十六、Memento，备忘录模式：在不破坏对象的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。 结构型有：十七、Composite，组合模式：将对象组合成树形结构以表示部分整体的关系，Composite使得用户对单个对象和组合对象的使用具有一致性。 十八、Facade，外观模式：为子系统中的一组接口提供一致的界面，facade提供了一高层接口，这个接口使得子系统更容易使用。 十九、Proxy，代理模式：为其他对象提供一种代理以控制对这个对象的访问 二十、Adapter,适配器模式：将一类的接口转换成客户希望的另外一个接口，Adapter模式使得原本由于接口不兼容而不能一起工作那些类可以一起工作。 二十一、Decrator，装饰模式：动态地给一个对象增加一些额外的职责，就增加的功能来说，Decorator模式相比生成子类更加灵活。 二十二、Bridge，桥接模式：将抽象部分与它的实现部分相分离，使他们可以独立的变化。 二十三、Flyweight，享元模式：运用共享技术有效地支持大量细粒度的对象。 感谢简书：Android的设计模式-设计模式的六大原则segmentfault：设计类六大原则掘金：设计模式精简图册新浪博客：关于23种设计模式","link":"/2019/04/02/JAVA六大设计原则 和 23种设计模式/"},{"title":" bat获取所有的参数\t\t","text":"bat默认只能获取到1-9个参数，分别用%1 %2 ... %9引用，而%0表示运行的bat命令。如果传给bat的参数大于9个，可以用shift。 当然还可以使用 %\\* 来获取全部的参数。 SHIFT [/n] 如果命令扩展名被启用， SHIFT 命令支持/n 命令行开关；该命令行开关告诉命令从第 n 个参数开始移位； n 介于零和八之间。例如:SHIFT /2会将 %3 移位到 %2，将 %4 移位到 %3，等等；并且不影响 %0 和 %1。 @echo off set allparam= :param set str=%1 if &quot;%str%&quot;==&quot;&quot; ( goto end ) set allparam=%allparam% %str% shift /0 goto param :end if &quot;%allparam%&quot;==&quot;&quot; ( goto eof ) rem remove left right blank :intercept_left if &quot;%allparam:~0,1%&quot;==&quot; &quot; set &quot;allparam=%allparam:~1%&quot;&amp;goto intercept_left :intercept_right if &quot;%allparam:~-1%&quot;==&quot; &quot; set &quot;allparam=%allparam:~0,-1%&quot;&amp;goto intercept_right :eof echo %allparam% pause 参考文献：bat获取所有的参数","link":"/2018/12/17/bat获取所有的参数/"},{"title":" chcp 修改显示格式\t\t","text":"CHCP 65001修改成 utf-8 , cmd重启不生效1 win键+R打开“运行”对话框，输入regedit打开注册表编辑器。2 找到 [HKEY_CURRENT_USER\\Console\\%SystemRoot%_system32_cmd.exe]3 修改”CodePage”=dword:000003a8（或者将进制改为十进制，然后输入936就可以了）【注】 2中可能不是%SystemRoot%_system32_cmd.exe名称；3中十六进制”000003a8″或十进制”936″，表示“936 (ANSI/OEM – 简体中文 GBK)” 写成bat文件执行utf-8.bat文件：@echo offCHCP 65001 GBK.bat文件：@echo offCHCP 65001 CMD中运行：路径\\utf-8.bat路径\\GBK.bat","link":"/2019/01/06/chcp 修改显示格式/"},{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/2019/03/28/hello-world/"},{"title":"Java设计模式 —— 单例模式(Singleton)","text":"单例模式最初的定义出现于《设计模式》（艾迪生维斯理, 1994）：“保证一个类仅有一个实例，并提供一个访问它的全局访问点。” 定义Java中单例模式定义：“一个类有且仅有一个实例，并且自行实例化向整个系统提供。” 特征： 只有一个实例对象，private构造函数 提供一个公有的方法获取实例对象，static getInstance方法 代码实现 饿汉模式 —— 没有 getInstance 获取实例对象，就已经new对象，加载类的时候就构造了单例懒汉模式 —— 在getInstance 获取实例对象使，才new对象 饿汉模式12345678910public class Singleton { private void Singleton() { } private static Singleton instance = new Singleton(); public static Singleton getInstance() { return instance; }} 懒汉模式12345678910111213public class Singleton { private void Singleton() { } private static Singleton instance; public static Singleton getInstance() { if (instance == null) { instance = new Singleton(); } return instance; }} 单例模式使用问题资源浪费 饿汉模式 —— 存在资源浪费问题，客户端一直不用这个对象咋办，但是饿汉模式不管，加载类就构造了单例，占用了资源。懒汉模式就不存在资源浪费。 多线程安全问题 饿汉模式 —— 是线程安全的，加载类就构造了单例对象。懒汉模式 —— 是线程不安全，单例对象可能null，加同步锁。 123456public static synchronized Singleton getInstance() { if (instance == null) { instance = new Singleton(); } return instance;} 12345678public static Singleton getInstance() { synchronized (Singleton.class) { if (instance == null) { instance = new Singleton(); } return instance; }} 多线程性能上面“懒汉模式”模式确实线程安全了，但是每次去执行getInstace方法都会受到同步锁的影响，运行的效率会降低 解决方法专有名词：双重锁定Double Check Lock（DCL） 就是先判断一下 12345678910public static Singleton getInstance() { if (instance == null) { synchronized (Singleton.class) { if (instance == null) { instance = new Singleton(); } } } return instance;} 一些奇葩方法：请查看Android中的设计模式之单例模式 静态内部类单例模式 枚举单例 使用容器实现单例模式 Android中单例模式InputMethodManager.javaxref: /frameworks/base/core/java/android/view/inputmethod/InputMethodManager.java 感谢guolin: Java设计模式透析之 —— 单例(Singleton)segmentfault: 标签 / 单例模式 / 标签动态百度百科： 单例模式","link":"/2019/04/08/singleton/"},{"title":" wordpress个人博客（阿里服务器）\t\t","text":"可查看：杂谈搭建个人博客选择比较一下个人博客选择 CSDN上https://blog.csdn.net/qq_23452385/article/details/83120255 1、购买域名和服务器可参考购买域名和服务器 https://yq.aliyun.com/articles/37204 https://blog.csdn.net/m0_37438418/article/details/79129420 2、下载FileZilla客户端和Wordpress压缩包 FileZilla是一个免费开源的FTP软件，分为客户端版本和服务器版本，具备所有的FTP软件功能。 Wordpress官方文档： https://codex.wordpress.org/zh-cn:Main_Page 1》使用FileZilla上传wordpress压缩包到服务器/htdocs目录下，在使用“主机管理平台”解压 1》使用FileZilla上传wordpress压缩包中wordpress/文件到服务器/htdocs目录下 注：wordpress压缩包中wordpress/在/htdocs站点根目录下，不包含wordpress目录 3、数据库验证避免WordPress报“建立数据库连接时出错”，验证数据库。 登陆阿里云，找到左侧“云虚拟主机”，全部主机-&gt;对应主机“操作”项选管理 跳转到“主机管理平台”，查看数据库信息，点击“管理”登陆到登陆到数据库DMS 修改wp-config.php wp-config.php 一开始是不存在于 WordPress 中的，您需要自己创建。请参照 wp-config-sample.php 文件样本来进行创建。 要对 wp-config.php 文件做修改，您需要如下信息： 参考https://codex.wordpress.org/zh-cn:%E7%BC%96%E8%BE%91wp-config.php 4、著名的WordPress五分钟安装程序 登陆到登陆到数据库DMS，查看数据 5、登陆个人网址http://xhbruce.cn 不要http://xhbruce.cn/wp-login.php不要后缀/wp-login.php这个没有登陆页面","link":"/2018/10/18/wordpress个人博客（阿里服务器）/"},{"title":" 【Google认证】STS：Android Security Test Suite\t\t","text":"STS Android Security Test Suite (STS). 是谷歌关于android安全补丁安装情况的一个测试套件 STS和security patch相关的，是CTS测试新增加一项安全测试套件。STS是201808才开始测试的。 Security patch日期在3个月内是GTS的一个case，如果不通过无法获得google认证。 在18年5月之前谷歌对于security patch这个属性都是在build库下面跟着aosp更新的。 现在需要通过STS之后由vendor来更新。 STS需要通过userdebug版本的targetfile来生成一个user版本的结果。 STS测试项 主要是测试 Android Security Patch 是否生效 测试说明 主要包含：那年那月的安全补丁、CVE安全补丁编号或Google与之对应的编号 android.security.sts.Pro【年_月】#testPro【CVE安全补丁编号】 android.security.sts.Poc17_07#testPocBug_33299365android.security.sts.Poc17_07#testPocBug_36604779 android.security.sts.Poc16_08#testPocCVE_2014_9904android.security.sts.Poc17_04#testPocCVE_2017_0583 check处理1、从Android每月安全补丁公告查找对应日期的对应CVE补丁patch，检查是否合入，一般是合入的 2、check没有合入，进行合入STS测试 3、check 合入没有生效，需要找芯片平台确认（如QCOM，一般CVE有对应的高通的CR号，提case咨询） 关注Security patch日期 Security patch日期在3个月内是GTS的一个case，如果不通过无法获得google认证。 例子 ：GtsOsTestCases–com.google.android.os.gts.SecurityPatchTest#testSecurityPatchDate 会有明确报错，需要更新日期：junit.framework.AssertionFailedError: ro.build.version.security_patch should be “2018-08” or later. Found “xxxx-xx-xx” Goolge最新通告，原定10.1开始STS要全部pass的规定；延迟期限未定！ Google官方说明请参考【“Security Test Suite (STS) Enforcement Schedule” announcement】 STS认证测试仍然参考之前方式送测： 【可以允许有fail】 【必须提供userdebug测试结果】","link":"/2018/11/12/【Google认证】STS：Android Security Test Suite/"},{"title":" ChkBugReport工具 for Android 2\t\t","text":"chkbugreport扩展功能Extending chkbugreport Java plugin：需要自己添加插件功能扩展 ExternalPlugin，并实现 initExternalPlugin 函数。麻烦，还需要 jar 文件~~~ XML Plugin：只需 xml 要按照特定格式配置就可，但是功能有局限性。 jar 文件或 xml 文件都需要放到特定文件夹目录下~/.chkbugreport 。这个一看是Linux下的，其实java获取的是”user.home”目录，在Windows上运行可以看到是 public static void main(String[] args) { //new Main().run(args); System.out.println(System.getProperty(“user.home”)); }运行结果：C:\\Users\\Administrator在 C:\\Users\\Administrator 创建.chkbugreport，直接是创建不成功的需要使用 “.chkbugreport.” 。XML Plugin 扩展功能—————可以使用xml文件格式的插件扩展/更改功能。### 运行 Plugin运行 Plugin 步骤（Module.java 中 runPlugins() 函数）： First, sort the plugins based on prio– 排序 Resetting and initializing data– 重置/初始化数据 Installing hooks– 安装hooks Then plugin should process the input data first– 处理Plugin输入的数据* Finally, each plugin should save the generated data–最后生成报告文件主要是最后三步的扩展功能。### 添加 XML plugin 插件代码添加 XML plugin 插件流程：BugReportModule.java -&gt; Module.java -&gt; loadExternalPlugins() -&gt; loadExternalXmlPlugin(File f) -&gt; addPlugin(new ExtXMLPlugin(xml))1、创建在 C:\\Users\\Administrator.chkbugreport 目录 2、添加 xml 文件example.xml： &lt;note text=&quot;Screen turning on&quot; error=&quot;true&quot; /&gt; &lt;/filter&gt; &lt;filter matchMsg=&quot;com.google.android.youtube&quot;&gt; &lt;!-- Add a yellow side-note to the log --&gt; &lt;note text=&quot;YouTube&quot; /&gt; &lt;/filter&gt; &lt;filter matchTag=&quot;ConnectivityService&quot; matchMsg=&quot;Ignoring protectedNetwork&quot;&gt; &lt;!-- Create a link from the &quot;Errors&quot; chapter --&gt; &lt;bug title=&quot;Something&apos;s fishy&quot; text=&quot;Lok at the log. Can you believe it?!&quot; prio=&quot;100&quot; type=&quot;phone err&quot; /&gt; &lt;/filter&gt; &lt;filter matchMsg=&quot;com.android.server.backup.BackupManagerService&quot;&gt; &lt;!-- Delete log lines --&gt; &lt;hide /&gt; &lt;/filter&gt; &lt;/hook&gt; &lt;hook into=&quot;EventLogPlugin&quot;&gt; &lt;filter matchMsg=&quot;games.provider.NotificationStubContentProvider&quot;&gt; &lt;!-- Add a red side-note to the log --&gt; &lt;!--note text=&quot;reboot&quot; error=&quot;true&quot; /--&gt; &lt;bug title=&quot;games.provider.NotificationStubContentProvider&quot; text=&quot;Lok at the log. Can you believe it?!&quot; prio=&quot;100&quot; type=&quot;phone err&quot; /&gt; &lt;/filter&gt; &lt;/hook&gt; &lt;generate&gt; &lt;chapter name=&quot;WTSpecialcharacters/Subchapter&quot;&gt; &lt;text&gt;WTSpecialcharacters/Subchapter&lt;/text&gt; &lt;log&gt; &lt;filter log=&quot;event&quot; matchTag=&quot;battery_level&quot; /&gt; &lt;filter log=&quot;system&quot; matchMsg=&quot;kill &quot; /&gt; &lt;filter log=&quot;main&quot; matchTag=&quot;PackageManager&quot; /&gt; &lt;/log&gt; &lt;/chapter&gt; &lt;/generate&gt; &lt;/plugin&gt; 3、cmd 中运行 chkbugreport …..\\bugreport_1542589813841.txt，查看报告……\\bugreport_1542589813841_out/index.html XML plugin 插件中xml文件标签详情&lt;plugin name=&quot;ExamplePlugin&quot;&gt; &lt;hook into=&quot;SystemLogPlugin&quot;&gt; ... &lt;/hook&gt; &lt;load&gt; ... &lt;/load&gt; &lt;generate&gt; &lt;chapter name=&quot;WTSpecialcharacters/Subchapter&quot;&gt; ... &lt;/chapter&gt; &lt;/generate&gt; &lt;/plugin&gt; 官方文档Xml plugins hookhook用于修改已存在插件的行为。依赖于目标插件，也就是源码中定义的 plugin。从github wiki上看并不是支持全部的plugin，仅仅只有BatteryInfoPlugin、SystemLogPlugin、MainLogPlugin 和 EventLogPlugin。 ●BatteryInfoPlugin扩展，支持在电池图表中添加额外的信息。但是在生成的HTML报告中并没有发现有变化，可能 plugin 本身功能齐全。BatteryInfoPlugin 有单独的 hooks.java 文件。 &lt;hook into=&quot;BatteryInfoPlugin&quot;&gt; &lt;logchart&gt; &lt;dataset id=&quot;batt&quot; name=&quot;Battery&quot; type=&quot;state&quot; colors=&quot;#fc8,#00f,#0f0,#f00&quot; /&gt; &lt;filter log=&quot;event&quot; matchTag=&quot;battery_status&quot; matchMsg=&quot;..*,.*,.*,(.*),.*\\]&quot; dataset=&quot;batt&quot; /&gt; &lt;/logchart&gt; &lt;/hook&gt; ● SystemLogPlugin, MainLogPlugin and EventLogPlugin 这三个都继承 LogPlugin.java。 &lt;hook into=&quot;SystemLogPlugin&quot;&gt; &lt;filter matchTag=&quot;WindowManager&quot; matchMsg=&quot;Screen turning on&quot;&gt; &lt;!-- Add a red side-note to the log --&gt; &lt;note text=&quot;Screen turning on&quot; error=&quot;true&quot; /&gt; &lt;/filter&gt; &lt;filter matchMsg=&quot;com.google.android.youtube&quot;&gt; &lt;!-- Add a yellow side-note to the log --&gt; &lt;note text=&quot;YouTube&quot; /&gt; &lt;/filter&gt; &lt;filter matchTag=&quot;ConnectivityService&quot; matchMsg=&quot;Ignoring protectedNetwork&quot;&gt; &lt;!-- Create a link from the &quot;Errors&quot; chapter --&gt; &lt;bug title=&quot;Something&apos;s fishy&quot; text=&quot;Lok at the log. Can you believe it?!&quot; prio=&quot;100&quot; type=&quot;phone err&quot; /&gt; &lt;/filter&gt; &lt;filter matchMsg=&quot;com.android.server.backup.BackupManagerService&quot;&gt; &lt;!-- Delete log lines --&gt; &lt;hide /&gt; &lt;/filter&gt; &lt;/hook&gt; hook子标签： 1、filter关注标签matchTag、matchMsg。matchTag 对应Android Log中的TAG；matchMsg 对应Android Log中的msg。根据这两个标签过滤。 2、子标签note 、bug 、hide 对 SystemLogPlugin 扩展，即对HTML报告中 system log/log 处理。note 是添加右侧报告的左侧提示 tag，如 “YouTube” 提示；bug 是对 system log/log 过滤 log，并生成到到HTML报告 Errors/ 中；hide 是对 system log/log 过滤 log 隐藏，不可见。 Load目前没有使用。github官方：The “load” tag is used only to collect data. Currently it’s not used. In the future it will be used to create tables in the databases and populate it from the log or from other data source. Generate&lt;generate&gt; &lt;chapter name=&quot;WTSpecialcharacters/Subchapter&quot;&gt; &lt;text&gt;WTSpecialcharacters/Subchapter&lt;/text&gt; &lt;log&gt; &lt;filter log=&quot;event&quot; matchTag=&quot;battery_level&quot; /&gt; &lt;!-- filter log=&quot;event&quot; matchTag=&quot;screen_toggled&quot; / --&gt; &lt;filter log=&quot;system&quot; matchMsg=&quot;kill &quot; /&gt; &lt;filter log=&quot;main&quot; matchTag=&quot;PackageManager&quot; /&gt; &lt;/log&gt; &lt;/chapter&gt; &lt;/generate&gt; 在HTML报告左侧目录中添加目录章节。 generate子标签： chapter 根据该标签 name 生成目录 text 生成的目录下的报告中，提示语句。 log 生成的目录下生成 log 报告。从代码中查看仅仅支持even、system、main，即HTML报告中 Even log/Log、System log/Log、Main log/Log 过滤 chkbugreport 对 Kernel log 、Last kmsg 支持在HTML报告中只是抓取 bugreport.txt 中 KERNEL LOG、LAST KMSG 的 log。 对应源码 KernelLogPlugin， 相较于 SystemLogPlugin MainLogPlugin EventLogPlugin （即 LogPlugin）没有实现覆盖父类的 public void onHook(Module mod, XMLNode hook) ，可能由于此，不能支持 hook扩展； 由于 com.sonyericsson.chkbugreport.plugins.extxml.Log.java 中对 generate/chapter/log/filter 标签下的 log 过滤，kernellog 不能支持 generate扩展。 目前xml扩展功能并不能支持kernellog 待续。。。。。。能否扩展到kernellog上","link":"/2019/01/06/ChkBugReport工具 for Android 2/"},{"title":" ChkBugReport工具 for Android 1","text":"BugReport Android 的 BugReport 一般是 .txt 结尾的文本文件，也有可能是 .log。当然了，命名没有限定。不要慌实质是一样的，就全部当成 .txt获取BugReport文件：adb bugreport &gt; bugreport.txt ChkBugReport介绍关于这个工具，找到的资料都比较旧了，貌似是索尼移动的开发人员开发的，2014年左右的文章比较多，应该是那个时候索尼移动还是比较鼎盛的时期吧。现在已经很少看到关于这个工具的文章了，应该是工具比较稳定健壮了，不需要太大的修改量了。 官方网站：http://developer.sonymobile.com/knowledge-base/tools/analyse-your-bugreports-with-our-open-source-tool/ 开源地址：https://github.com/sonyxperiadev/ChkBugReport 官网是这样介绍的ChkBugReport is a new bugreport analysis tools released as open source . 下面一段翻译自这里：安卓的开发者们，你们还在为经常碰到的ANR而感到头疼和不爽么，还在为应用崩溃而抓耳挠腮么？还在因为收集到的错误日志杂乱无章而感到束手无策么？ChkBugReport将为你解忧愁，解心宽，解决各种小困难。ChkBugReport,简单易用，简直是居家旅行，工作生活必备之良品。 点击查看 ChkBugReport 源码。 点击查看 ChkBugReport.jar 下载地址。 点击 information 查看相关说明 。 ChkBugReport 开源工具ChkBugReport是一个开源工具，它可以把你得到的bugreprot解析成适合阅读的html文件。导出的html文件包含了根据bugreport数据得出的图表和分析结论。 它的源码中用到了以下开源类库： jQuery ，jsTree jQuery plugin ， tablednd jQuery plugin ， tablesorter jQuery plugin ，js-hotkeys， jquery-cookie 。学习输出报告文档型html可以参考源码。 目前ChkBugReport可以从bugreport数据中抽取出如下信息： Stacktraces ChkBugReport可以从bugreport中解析出输出bugreport的最后时刻、导致ANR时刻甚至更多时刻的堆栈信息。在例子中你可以看到进程的优先级和策略都已标示出来，堆栈中耗时的部分颜色是黑红，一些违反Strict Mode的部分（比如主线程中使用数据库）颜色标记为亮红。如果这个线程死锁，在报告的Errors将会出现。 Logs 这部分是对system、main和kernel日志的分析，在这里你可以看到每个进程内存使用图、那个程序产生的log最多、Activity的启动耗时、数据库操作耗时统计、对象被锁定时间、AIDL调用时间、Activity和Service的生命周期及其在内存中使用频率等等，详见 Packages ChkBugReport解析bugreport中存储的packages.xml并展示一系列的packages、user ids和 permissions。参见 Processes 操作app过程中产生的系统事件日志、内存使用信息等等，参见 Battery statistics 电池使用统计信息，参见 CPU Frequency statistics CPU频率统计信息，参见 Raw data 被分割成小段的原始数据 同时ChkBugReport也可以检测到（潜在的）错误，这些错误在输出的报告Errors部分中可以找到。你也可以在输出报告的stacktrace中找到死锁或一些违反Strict Mode的行为。 ChkBugReport使用github上 How to use it java -jar $HOME/chkbugreport.jar $HOME/bugreport.txt $HOME 是一个环境变量，chkbugreport.jar目录的路径。 ChkBugReport 会为你生成一个文件夹，叫做 bugreport_out，文件夹里有个 index.html 文件，这就是我们的错误报告的网页了，是一个 HTML 文件。 你可以双击启动它 （如果你设置了 .html 文件用浏览器程序启动的话）， 或者用命令行，比如我用 firefox 浏览器来启动这个 HTML 文件： firefox bugreport_out/index.html 命令参数Command-line-options For a complete list of parameters just run the tool without any arguments. As of now the following parameters are handled: -ds:file - Use file as dumsys output (almost same as -pb) -el:file - Use file as event log -ft:file - Use file as ftrace dump -ml:file - Use file as main log -mo:file - Parse monkey output and extract stacktraces from it -pb:file - Load partial bugreport (eg. output of dumpsys) -pk:file - Load packages.xml file -ps:file - Use file as “processes” section -pt:file - Use file as “processes and threads” section -sa:file - Use file as “vm traces at last anr” section -sl:file - Use file as system log -sn:file - Use file as “vm traces just now” section -sd:dir - Load files from directory as partial bugreports -uh:file - Load usage-history.xml file Extra options (less frequently needed): –browser - Launch the browser when done –gui - Launch the Graphical User Interface if no file name is provided –silent - Supress all output except fatal errors –limit - Limit the input file size (default) If using the -sl option for example, the log file will be truncated if it’s too long (since the generated html would be even bigger). This option (and –no-limit as well) must precede the other options in order to have effect. –no-limit - Don’t limit the input file size NOTE: The graphical user interface is still experimental and very rudimentary 快捷方式 shell脚本创建一个 chkbugreport 的 Shell 脚本，放在 $HOME/bin 目录中 ： vim $HOME/bin/chkbugreport 在脚本中加入以下代码： #!/bin/sh DIR=$HOME/bin JAR=$DIR/chkbugreport-0.4-185.jar CP=$JARif [ ! -f $JAR]; thenecho&quot;为了这个脚本能够运行，请把下载的 ChkBugReport 的 JAR 包拷贝到 $JAR 中&quot;exit 1 fi java -jar $CP&quot;$@&quot; 为脚本添加可执行权限： chmod +x $HOME/bin/chkbugreport 确保 $HOME/bin 这个目录在 Path 环境变量中，请参看 Linux探索之旅 | 第五部分第二课：一入Shell深似海，酷炫外壳惹人爱 。 之后，cmd中运行 chkbugreportbugreport.txt bat脚本创建一个 chkbugreport.bat 的 bat 脚本，把 chkbugreport.bat 的路径加到环境变量中。在脚本中加入以下代码： @echo off java -jar E:\\Android\\chkbugreport\\chkbugreport-0.4-185.jar %1 之后，cmd中运行 chkbugreport &quot;bugreport.txt&quot; chkbugreport 报错C:\\Users\\Administrator&gt;chkbugreport C:\\Users\\Administrator\\Desktop\\download@tid[]=4573872\\4573872_2018-11-19-064158-3908515\\bugreport_1542589813841.txtWTChkBugReport 0.5 (rev 216) !!BASE ON ChkBugReport!!Failed to load plugin: com.sonyericsson.chkbugreport.AdbExtensionFile C:\\Users\\Administrator\\Desktop\\download@tid[] does not exists!Cannot open file: C:\\Users\\Administrator\\Desktop\\download@tid[] 注意：Windows 上最好添加双引号 chkbugreport “… …\\bugreport.txt” 参考文献Android神兵利器 | ChkBugReport输出网页版错误报告ChkBugReport工具for Androidandroid 使用开源工具ChkBugReport分析Bugreport","link":"/2018/12/17/ChkBugReport工具 for Android 1/"},{"title":" Java设计模式  —— 工厂方法(Factory Method)模式 、抽象工厂（Abstract Factory）模式","text":"工厂模式的定义 “Define an interface for creating an object, but let subclasses decide which class to instantiate. Factory Method lets a class defer instantiation to subclasses.”(在基类中定义创建对象的一个接口，让子类决定实例化哪个类。工厂方法让一个类的实例化延迟到子类中进行。) 简单工厂（Simple Factory）模式，又称静态工厂方法模式（Static Factory Method Pattern）。 工厂方法（Factory Method）模式，又称多态性工厂（Polymorphic Factory）模式或虚拟构造子（Virtual Constructor）模式； 抽象工厂（Abstract Factory）模式，又称工具箱（Kit 或Toolkit）模式。 定工厂方法(Factory Method)模式定义工厂方法：定义一个用于创建对象的接口，让子类决定实例化哪一个类，Factory Method使一个类的实例化延迟到了子类。 特征： 工厂(Factory)角色 :简单工厂模式的核心，它负责实现创建所有实例的内部逻辑。工厂类可以被外界直接调用，创建所需的产品对象。 抽象产品(Product)角色 :简单工厂模式所创建的所有对象的父类，它负责描述所有实例所共有的公共接口。 具体产品(Concrete Product)角色:简单工厂模式的创建目标，所有创建的对象都是充当这个角色的某个具体类的实例。定义工厂接口 代码实现创建一个可以绘制不同形状的绘图工具，可以绘制圆形，正方形，三角形，每个图形都会有一个draw()方法用于绘图. （1）创建Shape接口123public interface Shape { void draw();} （2）创建实现该接口的具体图形类圆形123456789public class Circle implements Shape { public Circle() { System.out.println(\"Circle\"); } @Override public void draw() { System.out.println(\"Draw Circle\"); }} 长方形123456789public class Rectangle implements Shape { public Rectangle() { System.out.println(\"Rectangle\"); } @Override public void draw() { System.out.println(\"Draw Rectangle\"); }} 正方形12345678910public class Square implements Shape { public Square() { System.out.println(\"Square\"); } @Override public void draw() { System.out.println(\"Draw Square\"); }} （3）创建工厂类：1234567891011121314151617public class ShapeFactory { // 使用 getShape 方法获取形状类型的对象 public static Shape getShape(String shapeType) { if (shapeType == null) { return null; } if (shapeType.equalsIgnoreCase(\"CIRCLE\")) { return new Circle(); } else if (shapeType.equalsIgnoreCase(\"RECTANGLE\")) { return new Rectangle(); } else if (shapeType.equalsIgnoreCase(\"SQUARE\")) { return new Square(); } return null; }} （4）测试方法：1234567891011121314151617public class Test { public static void main(String[] args) { // 获取 Circle 的对象，并调用它的 draw 方法 Shape circle = ShapeFactory.getShape(\"CIRCLE\"); circle.draw(); // 获取 Rectangle 的对象，并调用它的 draw 方法 Shape rectangle = ShapeFactory.getShape(\"RECTANGLE\"); rectangle.draw(); // 获取 Square 的对象，并调用它的 draw 方法 Shape square = ShapeFactory.getShape(\"SQUARE\"); square.draw(); }} 输出结果： CircleDraw CircleRectangleDraw RectangleSquareDraw Square 工厂方法模式使用问题 优点：1、一个调用者想创建一个对象，只要知道其名称就可以了。2、扩展性高，如果想增加一个产品，只要扩展一个工厂类就可以。3、屏蔽产品的具体实现，调用者只关心产品的接口。 缺点：每次增加一个产品时，都需要增加一个具体类和对象实现工厂，使得系统中类的个数成倍增加，在一定程度上增加了系统的复杂度，同时也增加了系统具体类的依赖。这并不是什么好事。 抽象工厂（Abstract Factory）模式定义抽象工厂：提供一个创建一系列相关或相互依赖对象的接口，而无须指定它们的具体类。 特征： 抽象工厂（AbstractFactory）角色 ：是工厂方法模式的核心，与应用程序无关。任何在模式中创建的对象的工厂类必须实现这个接口。 具体工厂类（ConreteFactory）角色 ：这是实现抽象工厂接口的具体工厂类，包含与应用程序密切相关的逻辑，并且受到应用程序调用以创建某一种产品对象。 抽象产品（Abstract Product）角色 ：工厂方法模式所创建的对象的超类型，也就是产品对象的共同父类或共同拥有的接口。 具体产品（Concrete Product）角色 ：抽象工厂模式所创建的任何产品对象都是某一个具体产品类的实例。在抽象工厂中创建的产品属于同一产品族，这不同于工厂模式中的工厂只创建单一产品，我后面也会详解介绍到。 代码实现步骤 1：为形状创建一个接口。Shape.java123public interface Shape { void draw();} 步骤 2：创建实现接口的实体类。Rectangle.java1234567public class Rectangle implements Shape { @Override public void draw() { System.out.println(\"Inside Rectangle::draw() method.\"); }} Square.java1234567public class Square implements Shape { @Override public void draw() { System.out.println(\"Inside Square::draw() method.\"); }} Circle.java1234567public class Circle implements Shape { @Override public void draw() { System.out.println(\"Inside Circle::draw() method.\"); }} 步骤 3：为颜色创建一个接口。Color.java123public interface Color { void fill();} 步骤4：创建实现接口的实体类。Red.java1234567public class Red implements Color { @Override public void fill() { System.out.println(\"Inside Red::fill() method.\"); }} Green.java1234567public class Green implements Color { @Override public void fill() { System.out.println(\"Inside Green::fill() method.\"); }} Blue.java1234567public class Blue implements Color { @Override public void fill() { System.out.println(\"Inside Blue::fill() method.\"); }} 步骤 5：为 Color 和 Shape 对象创建抽象类来获取工厂。AbstractFactory.java1234public abstract class AbstractFactory { public abstract Color getColor(String color); public abstract Shape getShape(String shape) ;} 步骤 6：创建扩展了 AbstractFactory 的工厂类，基于给定的信息生成实体类的对象。ShapeFactory.java12345678910111213141516171819202122public class ShapeFactory extends AbstractFactory { @Override public Shape getShape(String shapeType){ if(shapeType == null){ return null; } if(shapeType.equalsIgnoreCase(\"CIRCLE\")){ return new Circle(); } else if(shapeType.equalsIgnoreCase(\"RECTANGLE\")){ return new Rectangle(); } else if(shapeType.equalsIgnoreCase(\"SQUARE\")){ return new Square(); } return null; } @Override public Color getColor(String color) { return null; }} ColorFactory.java12345678910111213141516171819202122public class ColorFactory extends AbstractFactory { @Override public Shape getShape(String shapeType){ return null; } @Override public Color getColor(String color) { if(color == null){ return null; } if(color.equalsIgnoreCase(\"RED\")){ return new Red(); } else if(color.equalsIgnoreCase(\"GREEN\")){ return new Green(); } else if(color.equalsIgnoreCase(\"BLUE\")){ return new Blue(); } return null; }} 步骤 7：创建一个工厂创造器/生成器类，通过传递形状或颜色信息来获取工厂。1234567891011FactoryProducer.javapublic class FactoryProducer { public static AbstractFactory getFactory(String choice){ if(choice.equalsIgnoreCase(\"SHAPE\")){ return new ShapeFactory(); } else if(choice.equalsIgnoreCase(\"COLOR\")){ return new ColorFactory(); } return null; }} 步骤 8：使用 FactoryProducer 来获取 AbstractFactory，通过传递类型信息来获取实体类的对象。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647AbstractFactoryPatternDemo.javapublic class AbstractFactoryPatternDemo { public static void main(String[] args) { //获取形状工厂 AbstractFactory shapeFactory = FactoryProducer.getFactory(\"SHAPE\"); //获取形状为 Circle 的对象 Shape shape1 = shapeFactory.getShape(\"CIRCLE\"); //调用 Circle 的 draw 方法 shape1.draw(); //获取形状为 Rectangle 的对象 Shape shape2 = shapeFactory.getShape(\"RECTANGLE\"); //调用 Rectangle 的 draw 方法 shape2.draw(); //获取形状为 Square 的对象 Shape shape3 = shapeFactory.getShape(\"SQUARE\"); //调用 Square 的 draw 方法 shape3.draw(); //获取颜色工厂 AbstractFactory colorFactory = FactoryProducer.getFactory(\"COLOR\"); //获取颜色为 Red 的对象 Color color1 = colorFactory.getColor(\"RED\"); //调用 Red 的 fill 方法 color1.fill(); //获取颜色为 Green 的对象 Color color2 = colorFactory.getColor(\"Green\"); //调用 Green 的 fill 方法 color2.fill(); //获取颜色为 Blue 的对象 Color color3 = colorFactory.getColor(\"BLUE\"); //调用 Blue 的 fill 方法 color3.fill(); }} 步骤 9：执行程序，输出结果： Inside Circle::draw() method.Inside Rectangle::draw() method.Inside Square::draw() method.Inside Red::fill() method.Inside Green::fill() method.Inside Blue::fill() method. 抽象工厂模式使用问题 优点：当一个产品族中的多个对象被设计成一起工作时，它能保证客户端始终只使用同一个产品族中的对象。 缺点：产品族扩展非常困难，要增加一个系列的某一产品，既要在抽象的 Creator 里加代码，又要在具体的里面加代码。 工厂方法模式与抽象工厂模式比较 在工厂方法模式中具体工厂负责生产具体的产品，每一个具体工厂对应一种具体产品，工厂方法具有唯一性。 抽象工厂模式则可以提供多个产品对象，而不是单一的产品对象。 抽象工厂是生产一整套有产品的（至少要生产两个产品)，这些产品必须相互是有关系或有依赖的，而工厂方法中的工厂是生产单一产品的工厂。 Android中工厂方法、抽象工厂Android中的ThreadFactory就是使用了工厂方法模式来生成线程的，线程就是ThreadFactory的产品。 感谢郭霖的专栏 CSDN: https://blog.csdn.net/guolin_blog/article/category/1381137segmentfault:工厂模式深入理解工厂模式百度百科： 工厂方法模式 抽象工厂模式菜鸟教程：抽象工厂模式","link":"/2019/04/13/factory-pattern_abstract-factory-pattern/"}],"tags":[{"name":"设计模式","slug":"设计模式","link":"/tags/设计模式/"},{"name":"Java","slug":"Java","link":"/tags/Java/"},{"name":"bat","slug":"bat","link":"/tags/bat/"},{"name":"个人网站","slug":"个人网站","link":"/tags/个人网站/"},{"name":"STS","slug":"STS","link":"/tags/STS/"},{"name":"ChkBugReport","slug":"ChkBugReport","link":"/tags/ChkBugReport/"}],"categories":[{"name":"Java","slug":"Java","link":"/categories/Java/"},{"name":"bat","slug":"bat","link":"/categories/bat/"},{"name":"个人网站","slug":"个人网站","link":"/categories/个人网站/"},{"name":"CTS","slug":"CTS","link":"/categories/CTS/"},{"name":"ChkBugReport","slug":"ChkBugReport","link":"/categories/ChkBugReport/"}]}